// Code generated by ntaps. DO NOT EDIT.
package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/tiket/learn-crud/di"
	"github.com/tiket/learn-crud/infrastructure"
	"github.com/tiket/learn-crud/shared"
	"github.com/urfave/cli"
	// - main-import-end
)

func main() {
	container := di.Container

	err := container.Invoke(func(sh shared.Holder, inh infrastructure.Holder) error {
		app := cli.NewApp()

		app.Commands = append(app.Commands, NewRunCommand(sh, inh)...)

		// - migration-main-command-start
		app.Commands = append(app.Commands, NewMigrationCommand(sh)...)
		// - migration-main-command-end

		// - main-command-end

		if err := app.Run(os.Args); err != nil {
			log.Printf("%s", err)
			return err
		}

		return nil
	})

	if err != nil {
		panic(err)
	}
}

func NewRunCommand(sh shared.Holder, inh infrastructure.Holder) []cli.Command {
	return []cli.Command{
		{
			Name:  "run",
			Usage: "run as service",
			Action: func(_ *cli.Context) error {
				// - graceful shutdown
				sig := make(chan os.Signal)
				signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL, syscall.SIGTERM)

				go inh.ListenHttp()

				log.Println("application started!")

				<-sig

				// - graceful shutdown here
				sh.Close()

				return nil
			},
		},
	}
}

// - main-function-end

// - migration-command-start
func NewMigrationCommand(sh shared.Holder) []cli.Command {
	return []cli.Command{
		{
			Name:  "migrate",
			Usage: "migrate database",
			After: func(c *cli.Context) error {
				sh.Close()
				return nil
			},
			Subcommands: []cli.Command{
				{
					Name:   "check",
					Usage:  "check migration",
					Action: migrationCheck(sh),
				},
				{
					Name:   "up",
					Usage:  "update migration to latest version",
					Action: migrationUp(sh),
				},
				{
					Name:   "down",
					Usage:  "downgrade migration to previous version",
					Action: migrationDown(sh),
				},
				{
					Name:   "init",
					Usage:  "initialize migration table",
					Action: migrationInit(sh),
				},
			},
		},
	}
}

func migrationCheck(sh shared.Holder) func(c *cli.Context) error {
	return func(_ *cli.Context) error {
		if err := sh.Migration.Check(); err != nil {
			sh.Logger.Error(err.Error())
		}

		sh.Logger.Info("database already up to date!")
		return nil
	}
}

func migrationUp(sh shared.Holder) func(c *cli.Context) error {
	return func(_ *cli.Context) error {
		if err := sh.Migration.Up(); err != nil {
			sh.Logger.Error(err.Error())
		}

		return nil
	}
}

func migrationDown(sh shared.Holder) func(c *cli.Context) error {
	return func(_ *cli.Context) error {
		if err := sh.Migration.Down(); err != nil {
			sh.Logger.Error(err.Error())
		}

		return nil
	}
}

func migrationInit(sh shared.Holder) func(c *cli.Context) error {
	return func(_ *cli.Context) error {
		_ = sh.Migration.Initialize()
		return nil
	}
}

// - migration-command-end

// - your custom code goes below here
